# Python特殊メソッド一覧と「ふわふわ大福店」うさうさ店長の例

Pythonの**特殊メソッド（マジックメソッド）**について、新人向けに「ふわふわ大福店」のうさうさ店長を例に解説します！

## 主要な特殊メソッド一覧

| メソッド | 用途 | 呼ばれるタイミング |
|---------|------|------------------|
| `__init__` | 初期化 | インスタンス作成時 |
| `__str__` | 文字列表現 | `print()`や`str()`時 |
| `__repr__` | 開発者向け表現 | `repr()`や対話シェル表示時 |
| `__len__` | 長さ取得 | `len()`時 |
| `__add__` | 加算 | `+`演算子使用時 |
| `__eq__` | 等価比較 | `==`演算子使用時 |
| `__lt__` | 小なり比較 | `<`演算子使用時 |
| `__getitem__` | 要素取得 | `obj[key]`時 |
| `__setitem__` | 要素設定 | `obj[key] = value`時 |
| `__call__` | 呼び出し可能化 | `obj()`時 |
| `__enter__`/`__exit__` | コンテキスト管理 | `with`文使用時 |

---

## 🐰 ふわふわ大福店「うさうさ店長」実装例

```python
# ふわふわ大福店のうさうさ店長クラス
class UsausaTencho:
    """
    ふわふわ大福店のうさうさ店長クラス
    大福の在庫管理と販売を担当するクラスです
    """
    
    # __init__: オブジェクトの初期化メソッド（コンストラクタ）
    def __init__(self, name, daifuku_stock=10):
        # selfは自分自身のインスタンスを指す
        # nameパラメータを受け取り、インスタンス変数self.nameに代入
        self.name = name
        
        # daifuku_stockパラメータ（デフォルト値10）を受け取り、在庫数として保存
        self.daifuku_stock = daifuku_stock
        
        # 販売した大福の累計数を0で初期化
        self.sold_count = 0
        
        # 大福の価格を1個150円に設定
        self.price_per_daifuku = 150
    
    
    # __str__: 人間が読みやすい文字列表現（print()で呼ばれる）
    def __str__(self):
        # f-stringを使って、店長名と在庫数を含む文字列を返す
        return f"🐰 {self.name}店長（在庫: {self.daifuku_stock}個）"
    
    
    # __repr__: 開発者向けの詳細な文字列表現
    def __repr__(self):
        # クラス名と主要な属性を含む、再現可能な形式の文字列を返す
        return f"UsausaTencho(name='{self.name}', daifuku_stock={self.daifuku_stock})"
    
    
    # __len__: len()関数で在庫数を取得できるようにする
    def __len__(self):
        # 現在の大福在庫数を返す
        return self.daifuku_stock
    
    
    # __add__: +演算子で在庫を追加できるようにする
    def __add__(self, other):
        # otherが整数の場合
        if isinstance(other, int):
            # 現在の在庫数にother個を追加
            self.daifuku_stock += other
            # 自分自身を返す（メソッドチェーンを可能にする）
            return self
        # otherが別のUsausaTenchoインスタンスの場合
        elif isinstance(other, UsausaTencho):
            # 相手の在庫数を自分の在庫に追加
            self.daifuku_stock += other.daifuku_stock
            # 自分自身を返す
            return self
        # それ以外の型の場合
        else:
            # エラーを発生させる
            raise TypeError("整数またはUsausaTenchoオブジェクトのみ追加できます")
    
    
    # __sub__: -演算子で大福を販売できるようにする
    def __sub__(self, quantity):
        # quantityが整数でない場合はエラー
        if not isinstance(quantity, int):
            # TypeError例外を発生させる
            raise TypeError("販売個数は整数で指定してください")
        
        # 在庫が足りない場合
        if quantity > self.daifuku_stock:
            # ValueError例外を発生させる
            raise ValueError(f"在庫不足です！（在庫: {self.daifuku_stock}個）")
        
        # 在庫から販売個数を減らす
        self.daifuku_stock -= quantity
        
        # 累計販売数に追加
        self.sold_count += quantity
        
        # 自分自身を返す
        return self
    
    
    # __eq__: ==演算子で在庫数の比較ができるようにする
    def __eq__(self, other):
        # otherがUsausaTenchoインスタンスの場合
        if isinstance(other, UsausaTencho):
            # 両者の在庫数が等しいかを返す
            return self.daifuku_stock == other.daifuku_stock
        # それ以外の場合はFalseを返す
        return False
    
    
    # __lt__: <演算子で在庫数の大小比較ができるようにする
    def __lt__(self, other):
        # otherがUsausaTenchoインスタンスの場合
        if isinstance(other, UsausaTencho):
            # 自分の在庫が相手より少ないかを返す
            return self.daifuku_stock < other.daifuku_stock
        # それ以外の場合はFalseを返す
        return False
    
    
    # __getitem__: インデックスアクセスで情報取得
    def __getitem__(self, key):
        # keyが'stock'の場合は在庫数を返す
        if key == 'stock':
            return self.daifuku_stock
        # keyが'sold'の場合は販売数を返す
        elif key == 'sold':
            return self.sold_count
        # keyが'price'の場合は価格を返す
        elif key == 'price':
            return self.price_per_daifuku
        # それ以外のkeyの場合はエラー
        else:
            # KeyError例外を発生させる
            raise KeyError(f"'{key}'は無効なキーです")
    
    
    # __setitem__: インデックスアクセスで値を設定
    def __setitem__(self, key, value):
        # keyが'stock'の場合
        if key == 'stock':
            # 在庫数を更新
            self.daifuku_stock = value
        # keyが'price'の場合
        elif key == 'price':
            # 価格を更新
            self.price_per_daifuku = value
        # それ以外のkeyの場合はエラー
        else:
            # KeyError例外を発生させる
            raise KeyError(f"'{key}'は設定できません")
    
    
    # __call__: インスタンスを関数のように呼び出し可能にする
    def __call__(self, customer_name, quantity=1):
        # 顧客名とデフォルト1個の数量を受け取る
        try:
            # 自分自身から quantity 個減算（販売処理）
            self - quantity
            
            # 売上金額を計算
            revenue = quantity * self.price_per_daifuku
            
            # 販売メッセージを返す
            return f"🐰 {customer_name}様、ありがとうございます！大福{quantity}個で{revenue}円です"
        
        # 在庫不足などのエラーが発生した場合
        except ValueError as e:
            # エラーメッセージを返す
            return f"🐰 申し訳ございません...{e}"
    
    
    # __enter__: with文の開始時に呼ばれる
    def __enter__(self):
        # 営業開始メッセージを表示
        print(f"🐰 {self.name}店長: 本日の営業を開始します！")
        
        # 自分自身を返す（withブロック内で使用可能にする）
        return self
    
    
    # __exit__: with文の終了時に呼ばれる
    def __exit__(self, exc_type, exc_val, exc_tb):
        # exc_typeは例外の型、exc_valは例外の値、exc_tbはトレースバック
        
        # 営業終了メッセージを表示
        print(f"🐰 {self.name}店長: 本日の営業終了！")
        
        # 本日の売上報告を表示
        print(f"   本日の販売数: {self.sold_count}個")
        
        # 残り在庫を表示
        print(f"   残り在庫: {self.daifuku_stock}個")
        
        # Falseを返すと例外を再発生、Trueを返すと例外を抑制
        # ここではNone（False扱い）を返して通常の例外処理に任せる
        return False


# ======================
# 使用例: 各特殊メソッドのデモ
# ======================

# __init__の実行: インスタンス作成
usagi = UsausaTencho("うさうさ", daifuku_stock=20)

# __str__の実行: print()で人間向けの表示
print(usagi)  # 🐰 うさうさ店長（在庫: 20個）

# __repr__の実行: 開発者向けの詳細表示
print(repr(usagi))  # UsausaTencho(name='うさうさ', daifuku_stock=20)

# __len__の実行: len()で在庫数取得
print(f"在庫数: {len(usagi)}個")  # 在庫数: 20個

# __add__の実行: +演算子で在庫追加
usagi + 10  # 在庫が30個になる
print(f"追加後: {len(usagi)}個")  # 追加後: 30個

# __sub__の実行: -演算子で販売
usagi - 5  # 5個販売、在庫が25個になる
print(f"販売後: {len(usagi)}個")  # 販売後: 25個

# __getitem__の実行: インデックスアクセスで情報取得
print(f"在庫: {usagi['stock']}個")  # 在庫: 25個
print(f"販売数: {usagi['sold']}個")  # 販売数: 5個
print(f"価格: {usagi['price']}円")  # 価格: 150円

# __setitem__の実行: インデックスアクセスで値設定
usagi['price'] = 180  # 価格を180円に変更
print(f"新価格: {usagi['price']}円")  # 新価格: 180円

# __call__の実行: インスタンスを関数のように呼び出し
message = usagi("田中", 3)  # 田中さんに3個販売
print(message)  # 🐰 田中様、ありがとうございます！大福3個で540円です

# __eq__と__lt__の実行: 比較演算子
mochi = UsausaTencho("もちもち", daifuku_stock=22)  # 別の店長を作成
print(f"在庫が同じ？ {usagi == mochi}")  # False
print(f"うさうさ店長の在庫が少ない？ {usagi < mochi}")  # True

# __enter__と__exit__の実行: with文でコンテキスト管理
print("\n--- with文での使用 ---")
with UsausaTencho("ぴょんぴょん", daifuku_stock=15) as pyon:
    # with文のブロック内で営業
    pyon("佐藤", 2)  # 販売処理
    pyon("鈴木", 3)  # 販売処理
# withブロックを抜けると自動的に__exit__が呼ばれ、営業終了処理が実行される
```

## 📝 実行結果

```
🐰 うさうさ店長（在庫: 20個）
UsausaTencho(name='うさうさ', daifuku_stock=20)
在庫数: 20個
追加後: 30個
販売後: 25個
在庫: 25個
販売数: 5個
価格: 150円
新価格: 180円
🐰 田中様、ありがとうございます！大福3個で540円です
在庫が同じ？ False
うさうさ店長の在庫が少ない？ True

--- with文での使用 ---
🐰 ぴょんぴょん店長: 本日の営業を開始します！
🐰 ぴょんぴょん店長: 本日の営業終了！
   本日の販売数: 5個
   残り在庫: 10個
```

## 🎯 ポイント

1. **`__init__`**: オブジェクトの「生まれた瞬間」の設定
2. **`__str__`**: ユーザーに見せる「顔」
3. **`__repr__`**: デバッグ用の「本当の姿」
4. **演算子オーバーロード**: `+`や`-`を自然に使える
5. **`__call__`**: オブジェクトを関数のように使える
6. **コンテキストマネージャ**: `with`文で自動的に開始・終了処理

特殊メソッドを使うと、Pythonの組み込み機能と同じように直感的にクラスを使えます！🐰✨
